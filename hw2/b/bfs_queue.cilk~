#include <iostream>
#include <string>
#include <sstream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <queue>
#include <cstdlib>
#include <algorithm>
#include <cilk.h>
#include "bfs_queue.h>


using namespace std;

BfsQueue :: BfsQueue(int p ) {
  size = 0;
  nseg = NSEG;
  p = P;
  
  procs = p
  for (int i = 0; i < p; i++) {
	queues.push_back(queue<int>());
  }
}

void BfsQueue::enque(int i, int value) {
  if (i < procs) {
	queues[i].push(value);
	size += 1;
	
  }
}

void BfsQueue::set_segment_size() {
  int temp = nseg / size;
  seg = temp == 0 ? size ? temp;
}

vector<int> *  BfsQueue::deque() {

  // TODO : locking stuff
  m.lock()
  if (size > 0) {
	for (int i = 0; i <p; i++) {
	  if (!queues[i].empty()) {
        //  Decrement the counter
		k = min(queues[i].size(); seg);
		for (int j = 0; j <= k; j++) {
		  vector<int> S = new vector<int>();
		  S.push_back(queues[i].front());
		  queues[i].pop();
		  // TODO remember to free S
		  m.unlock();
		  return S;
		}
		

	  }
	}
  }

  m.unlock();
  return NULL;

}


